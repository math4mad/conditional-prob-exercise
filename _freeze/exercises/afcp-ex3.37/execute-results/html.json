{
  "hash": "c15bc92ba1b4bde0a0e2b2e96e7a7187",
  "result": {
    "markdown": "---\ntitle: 1. question\n---\n\n\n> 赌徒口袋中有一枚均匀的硬币, 还有一枚两面都是正面的硬币,他随机拿出一枚硬币\n>\n> - (a) 抛出来是正面, 是均匀硬币的概率\n> - (b) 再抛一次,仍是正面, 是均匀硬币的概率\n> - (c) 第三次抛,发现是反面,是均匀硬币的概率\n\n## 2. (a) 的概率路径图\n\n```{mermaid}\nflowchart LR\n    A(Coin)==fc:1/2==>B(faircoin)\n    A(Coin)==nfc:1/2==>C(notfaircoin)\n    B(faircoin)==fc1h:1/2==>D(head)\n    B(faircoin)-.fc1t:1/2.->E(tail)\n    C(notfaircoin)==nfc1h:1==>F(head)\n    style D  fill: #FF0000, stroke: #333, stroke-width: 2px;\n    style F  fill: #FF0000, stroke: #333, stroke-width: 2px;\n    \n```\n\n第一次抛出正面的概率有两个路径,均匀硬币是第一条路径\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfc=nfc=1//2\nfc1h=fc1t=1//2\nnfc1h=1;nfc1t=0\npath1=fc*fc1h\npath2=nfc*nfc1h\np1head=path1+path2\n\n\"第一次抛出正面条件下,为均匀硬币的概率\"=>path1//p1head\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n\"第一次抛出正面条件下,为均匀硬币的概率\" => 1//3\n```\n:::\n:::\n\n\n## 3. (b) 的概率路径图\n\n```{mermaid}\nflowchart LR\n    A(Coin)==fc:1/2==>B(faircoin)\n    A(Coin)==nfc:1/2==>C(notfaircoin)\n    B(faircoin)==fc1h:1/2==>D(head)\n    B(faircoin)==fc1t:1/2==>E(tail)\n    C(notfaircoin)==nfc1h:1==>F(head)\n    \n    D(head)==fc2h:1/2==>I(head)\n    D(head)==fc2t:1/2==>J(tail)\n    E(tail)==fc2h:1/2==>K(head)\n    E(tail)==fc2t:1/2==>L(tail)\n    F(head)==nfc2h:1==>M(head)\n\n    style D  fill: #FF0000, stroke: #333, stroke-width: 2px;\n    style F  fill: #FF0000, stroke: #333, stroke-width: 2px;\n    style I  fill: #FF0000, stroke: #333, stroke-width: 2px;\n    style M  fill: #FF0000, stroke: #333, stroke-width: 2px;\n    \n```\n\n第一次抛是正面, 第二次仍是正面仍是两条路径,但是概率发生变化\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\n    fc2h=fc2t=1//2\n    nfc2h=1\n    path3=fc*fc1h*fc2h\n    path4=nfc*nfc1h*nfc2h\n    p2head=path3+path4\n    \"第一次抛是正面, 第二次仍是正面的硬币是均匀硬币的概率\"=>path3//p2head\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n\"第一次抛是正面, 第二次仍是正面的硬币是均匀硬币的概率\" => 1//5\n```\n:::\n:::\n\n\n## 4. (c) 的概率路径图\n实际因为两面都是人头的硬币不可能出现反面, 一旦出现反面, 整个路径就不存在. \n这就是著名的黑天鹅理论. 对于硬币试验, 如果从开始连续抛硬币都是正面,不能因为没有观察\n到反面的现象,就匆忙下结论:硬币两面都是正面, 这个结论是经不起试验验证的.\n\n因为即使观察到连续100次正面,一旦观察到一次反面,整个对模型的结论就完全失去作用了. \n\n我们看到 100 次白天鹅,不能下结论:所有天鹅都是白色的, 因为只要观察到一只黑天鹅, 这个结论\n就是错误的.\n\n\n```{mermaid}\nflowchart LR\n    A(Coin)==fc:1/2==>B(faircoin)\n    A(Coin)==nfc:1/2==>C(notfaircoin)\n    B(faircoin)==fc1h:1/2==>D(head)\n    B(faircoin)==fc1t:1/2==>E(tail)\n    C(notfaircoin)==nfc1h:1==>F(head)\n    \n    D(head)==fc2h:1/2==>I(head)\n    D(head)==fc2t:1/2==>J(tail)\n    E(tail)==fc2h:1/2==>K(head)\n    E(tail)==fc2t:1/2==>L(tail)\n    F(head)==nfc2h:1==>M(head)\n    I(head)==fc3h:1/2==>N(head)\n    I(head)==fc3t:1/2==>O(tail)\n\n    style D  fill: #FF0000, stroke: #333, stroke-width: 2px;\n    style I  fill: #FF0000, stroke: #333, stroke-width: 2px;\n    style O  fill: #FF0000, stroke: #333, stroke-width: 2px;\n```\n\n`head->head->tail` 的路径只有一条,所以如果第三次抛出反面,肯定这枚硬币是均匀的硬币\n\n",
    "supporting": [
      "afcp-ex3.37_files"
    ],
    "filters": [],
    "includes": {}
  }
}